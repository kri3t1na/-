Начало

Добавление элемента key в бинарное дерево поиска
{ ЕСЛИ узлов в дереве еще нет
        ТО создаем узел дерева
        введенное значение становится корнем
        создаем левое и правое поддеревья
  ЕСЛИ значение key < корня дерева
      ТО переходим в левое поддерево
      ЕСЛИ в левом поддереве нет элементов дерева
          ТО добавляем key в левое поддерево
           создаем для добавленного значения левое и правое поддеревья
      ИНАЧЕ временно принимаем значение элемента поддерева корнем
          переходим к добавлению элемента
          пока не произойдет добавление элемента в поддерево
  ЕСЛИ значение key > корня дерева
      ТО переходим в правое поддерево
      ЕСЛИ в правом поддереве нет элементов дерева
          ТО добавляем key в правое поддерево
          создаем для добавленного значения левое и правое поддеревья
      ИНАЧЕ временно принимаем значение элемента поддерева корнем
      переходим к добавлению элемента
      пока не произойдет добавление элемента в поддерево
  }

Проверяем сбалансированность бинарного дерева поиска
{ Считаем высоту левого поддерева
  Считаем высоту правого поддерева
  ЕСЛИ высоты левого и правого поддерева отличаются больше чем на 1
      ТО переходим к балансировке бинарного дерева поиска
  ИНАЧЕ
      продолжаем добавление элементов в дерево
  }

Балансировка бинарного дерева поиска
{ ЕСЛИ высота правого поддерева > высоты левого поддерева
      ТО ищем минимальный элемент правого поддерева
      минимальный элемент становится корнем дерева (правое поддерево не изменяется)
      удаляем минимальный элемент из правого поддерева
      предыдущий корень дерева становится его левым потомком, сохраняя левое поддерево
  ИНАЧЕ ищем максимальный элемент левого поддерева
      найденный максильный элемент становится корнем дерева
      удаляем максимальный элемент из левого поддерева
      ЕСЛИ у максимального элемента 2 потомка
          ТО больший из них помещается на место удаленного
      ИНАЧЕ потомок максимального элемента встает на его место(с сохранением своих потомков)
      предыдущий корень дерева становится его правым потомком, сохраняя правое поддерево
  }

Вводим количество узлов (элементов) бинарного дерева, N
Цикл повторяем N раз
{ Вводим значение элемента(узла) дерева, key
  Добавляем элемент в бинарное дерево поиска
  Проверяем сбалансированность бинарного дерева поиска
  Выводим сбалансированное бинарное дерево поиска
  }

Конец

